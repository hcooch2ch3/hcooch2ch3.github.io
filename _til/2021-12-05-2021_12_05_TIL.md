---
layout: post
title: 2021.12.05 TIL
tags: TIL
---
# TIL(Today I Learned)

12월 5일(일)

**학습내용**

- SwiftUI(CS193p Lecture 5)
    - View는 Read-Only이다.
        - Read-Only이므로 외부에서 변환시킬일이 없으므로 View의 프로퍼티는 모두 상수여야 한다.  (@State, @ObservedObject를 제외하고)
        - Stateless
    - @State
        - @State 는 View의 상태를 나타내기 위해 사용한다.
        
        ```swift
        @State private var somethingTemporary: SomeType // SomeType은 struct이여야 한다.
        ```
        
        - 접근 제한은 private이여야 한다. (View 내부에서만 사용되어야 하므로)
        - 또한 변수의 타입은 struct type이여야 한다.
        - @State의 변수 값이 변하면 뷰를 재생성한다.
        - @State의 변수는 View의 lifetime 동안 heap에 살아있다.
            - 여기서 lifetime이란, View가 화면에 나타나 있는 동안을 의미한다. (View struct의 lifetime이 아닌)
        - View가 재생성되면 State 변수는 heap에 있는 내용을 다시 point 하게 된다.
        - @State은 "source of truth"이다.
        - @State 사용을 너무 남용하면 안된다.
        - Model에 포함되지 않아야 한다.
    - ViewModel
        - View와 model 사이의 gatekeeper이다.
        - ViewModel은 View에 보여지고 싶은 model을 노출시킨다.
        - ViewModel의 Intent Function을 통해서만 model을 변경할 수 있다. (Intent Function을 통해서 사용자와 상호작용)
    - View
        - View 내부에 non-private var와 func을 선언하는 경우는 드물다. (View가 ephemeral하므로, 즉 오래동안 지속되지 않으므로)
    - Access Control
        - open과 public은 주로 library code에서만 사용된다.
        - internal이 기본이며, app 내부에서 접근이 가능하다.
        - static 함수도 private이 가능하다. (private static)
    - Xcode 변수명 변경방법
        - 변경하려는 변수명을 command 키와 같이 누르면 말풍선이 뜨는데, rename을 클릭한다.
    - Computed Property
        - Computed Property 내부에 get {}, set {}을 구현할 수 있다.
        - set 내부에서 입력 값을 newValue로 참조할 수 있다.
            
            ```swift
            private var indexOfTheOneAndOnlyFaceUpCard: Int? {
                get { cards.indices.filter({cards[$0].isFaceUp }).oneAndOnly }
                set { cards.indices.forEach { cards[$0].isFaceUp = ($0 == newValue) } }
            }
            ```
            
    - Property Observers
        - willSet, didSet
            - willSet - newValue
            - didSet - oldValue
    - Layout
        - 뷰가 어떻게 공간을 할당하는가?
            1. Container View은 하위 뷰에 space을 제공한다.
            2. View는 자기 자신의 크기를 스스로 결정한다.
            3. Container View는 크기가 결정된 하위 뷰를 적절하게 위치시칸다.
            4. 2번 과정과 같이 Container View도 스스로 크기를 결정한다.
        - HStck, VStack
            - 하위 뷰 중 제일 flexible하지 않은 뷰에 먼저 space을 제공한다.
                - Image(inflexible) : 고정된 크기로 존재하려 한다.
                - Text(slightly more flexible) : 텍스트에 맞는 크기로 존재하려 한다.
                - RoundedRectangle(very flexible) : 제공된 공간을 다 차지하려 한다.
            - Spacer
            - Divider
            - layoutPriority
            - alignment
                - .leading vs .left
                    - left는 절대적 위치(왼쪽) leading은 기기 언어설정에 맞게 왼쪽 또는 오른쪽이 될 수 있다. (Arabic 또는 Hebrew)
        - LazyHStack, LazyVStack
        - ScrollView
        - LazyHGrid and LazyVGrid
        - List and Form and OutlineGroup
        - ZStack
        - .background modifier
        - .overlay modifier
        - Modifiers
            - padding
            - aspectRatio

**참고**

- [https://youtu.be/ayQl_F_uMS4](https://youtu.be/ayQl_F_uMS4)
