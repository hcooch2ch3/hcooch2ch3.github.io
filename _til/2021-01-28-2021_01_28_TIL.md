---
layout: post
title: 2021.01.28 TIL
tags:
---
# TIL(Today I Learned)

1월 28일(목)

**학습내용**

- 프로토콜 지향 프로그래밍(Protocol Oriented Programming)
    - 상속은 기능을 추가, 확장을 위한 목적으로 필요하지만 다중상속이 불가능하다는 한계가 있다.
    - 프로토콜 지향 프로그래밍으로 객체지향 프로그래밍은 다중상속이 불가능하다는 단점을 극복할 수 있음.
    - protocol extension은 프로토콜의 기본구현을 제공한다. 프로토콜 기본구현으로 인해서 프로토콜을 채택할 때 매번 같은 기능을 구현해야하는 불편을 없애준다. (필요에 따라 타입에서 구현하면 된다.)
    - protocol extension은 protocol의 함수를 오버라이드?(구현) 할 수 없다.
    - 또한 상속은 클래스만 가능했지만, 프로토콜은 enum, struct에서 가능하다는 장점이 있다.
    - 성능을 위해서 struct, enum 등 value type을 이용하는 것이 class를 이용하는 것보다 낫다.

**문제점/고민한점**

1. 왜 스위프트의 객체지향 프로그래밍은 다중상속을 지원하지 않을까?
2. 객체지향 프로그래밍에서 다중상속을 하면 다이아몬드 문제가 발생할 수 있다는데, 왜 프로토콜에서는 다이아몬드 문제가 발생하지 않을까?

**해결방법**

1. 객체지향 프로그래밍이 다중상속을 지원할 경우 다이아몬드 문제가 발생할 수 있기 때문이다. 다이아몬드 문제란 A를 B와 C가 상속하고 D가 B, C를 다중 상속하는 것처럼 다이아몬드 형태로 상속을 할때 발생하는 문제이다. A의 함수를 B, C가 각각 오버라이드 하고, D가 그 함수를 오버라이드 하려고 할때 B, C의 함수 중 어떤것을 지칭하는지 알 수 없다는 것이 다이아몬드 문제이다.
2. A 프로토콜을 B, C 둘이 채택하고 B, C를 D가 다중상속한다고 하자. B, C에 같은 함수가 있어도, B, C 모두 프로토콜이기 때문에 함수 내부 구현이 되어있지 않으므로 오버라이드에 대한 문제가 발생하지 않는다.

**참고**

- [https://siyoon210.tistory.com/125](https://siyoon210.tistory.com/125)
- [https://en.wikipedia.org/wiki/Multiple_inheritance](https://en.wikipedia.org/wiki/Multiple_inheritance)
